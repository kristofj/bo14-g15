%\cleardoublepage
\chapter{Produksjon}
\label{chap:production} 

I dette kapittelet vil vi ta for oss hvordan vi har produsert resultatene i proskjetet og beskrive selve produktet. Vi tar med hvilke verktøy vi har brukt, hvordan produksjonen foregikk, delegering av oppgaver og hvordan vi har løst problemer som har oppstått.

\section{Maskinvare}
\label{sec:HardwareDelen}

\meta{Ting å nevne: jobbet på verkstedet på skolen.. etc.. loddet sammen komponenter, bygd deksel og beskyttelse til sensorene.} \\

\subsection{Tilpassing for montering i felt}

Vi har laget to værstasjoner som skal monteres på to forskjellige steder. Den ene skal festes til en mast ved hovedstasjonen og den andre skal festes til et tre ved sekundærstasjonen.
\subsubsection{Vindsensorene}
Som tilbehør til vindsensorene fikk vi tak i en monteringsstang, vist i figur \ref{fig:monteringsstang}, fra samme produsent som er beregnet for disse sensorene. Sensorene festes og løsnes enkelt fra monteringsstangen ved å skru på to låseskiver som sitter rett over lendningen ut fra sensorene. Selve monteringsstangen festes til ønsket plass ved hjelp av to metallbånd og tilhørende låsemekanisme. 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.50\textwidth]{zmo40}
  \caption{Monteringsstang for vindsensorene}
  \label{fig:monteringsstang}
\end{figure}
\subsubsection{BMP180}
\label{subsubsec:hardwarebmp180}
Lufttrykksensoren BMP180 ble vi nødt til å montere i en koblingsboks da den ikke har noen form for beskyttelsesetui. Dette ble gjort ved å lodde fast sensoren til et koblingsbrett som ble skrudd fast inne i koblingsboksen. For å sikkre en tett kabelgjennomføring benyttet vi kabelnipler. Sensoren er også avhengig av luftgjennomstrøming i boksen for at måling av lufttrykket skal bli korrekt. Dette ble løst ved å lage et lite hull i siden og et i bunnen for drenering av vann som kan renne inn.

Festeanordningen til luftrykksensoren ved hovedstasjonen lagde vi av et bøybart metallbånd med hull i. Dette ble festet til boksen og deretter til masten ved å bøye metallbåndet rundt soltpene i masten og skru det fast med maskinskruer. Ved sekundærstasjonen ble boksen festet rett til treet ved bruk av treskruer. Dette ser du på figur \ref{fig:ferdigmontert} i avsnitt \ref{subsec:tilpassing}.

\subsubsection{SHT10}
For at temperaturmålingene ikke skal bli påvirket av direkte sollys har vi valgt å feste sensoren i en hvit koblingsboks. Koblingsboksen har tillstrekklig med åpninger for gjennomlufting slik at luften inne i boksen holder samme temperatur som på utsiden. Måten den er montert ved de to stasjonene er gjort på samme vis som ved BMP180, beskrevet i avsnittet ovenfor. 

\subsection{Tilpassing av kabinettet}
\label{subsec:tilpassing}

Det vi valge å bruke som kabinett på værstasjonen er et skap av stål med beskyttelsesgrad IP 66. Dette er mer en tilstrekkelig for utendørs montering. Vi har også gjort ett par tillegsmodifikasjoner. Innvendig har vi isolert det med isopor og montert en termostat som styrer et varmeelement for å forhindre kondes og frost. Termostaten slår på varmeelementet ved  $5\,^{\circ}\mathrm{C}$ og av ved $15\,^{\circ}\mathrm{C}$.

Komponentene som skal huses i kabinettet er skrudd fast i tilhørende monterinsplate som fulgte med kabinettet. Selve festeanordningen til kabinettetene for å feste de ved hovedstasjon og sekundærstasjonen er laget av metallbånd med skruehull. På figur \ref{fig:ferdigmontert}  ser du hvordan dette ble gjort. 

\begin{figure}[H]
        \centering
        \begin{subfigure}[H]{0.45\textwidth}
                \includegraphics[width=\textwidth, angle = 90]{hovedstasjon}
                \caption{Hovedstasjon}
                \label{fig:hovedstasjon}
                \quad
        \end{subfigure}
        \begin{subfigure}[H]{0.45\textwidth}
                \includegraphics[width=\textwidth]{stasjon2}
                \caption{Sekundærstasjon}
                \label{fig:sekundstasjon}
                \quad
        \end{subfigure}
        \caption{Værstasjonene montert ved målestasjonene}\label{fig:ferdigmontert}
\end{figure}

\subsubsection{Innredning i kabinettet}

I figur \ref{fig:innredning} ser du hvordan vi har innredet kabinettet. Vi har tatt høyde for at kablene til strømforskyningene kan fåresake støy som kan påvirke avlesningen av sensorene. Defor har vi lagt disse mest mulig utenom mikrokontrolleren, koblingsbrettet og sensorledningene.   

\begin{figure}[H]
	\centering
    \includegraphics[width=\textwidth]{innredning}
    \caption{Innredning i kabinettet}
  	\label{fig:innredning}
\end{figure}

Varmeelementet er festet til en trekloss i lokket fremfor direkte til monteringsstripa i lokket. Slik unngår vi varmetapet som hadde oppstått om vi hadde festet det direkte til monteringsstripa. Denne plasseringen var også den mest taktiske for å unngå at strålingsvarmen fra elementet kan komme til å smelte i stykker komponenter rundt, og for å få plassert det så lavt som mulig.

Termostaten, som styrer varmeelementet, er festet lavt i sideveggen på motsatt side av varmeelementet og strømforskyningene. Dette for å unngå at det blir påvirket av andre faktorer enn luften inne i kabinettet og fordi det er her det blir lavest temperatur. Det gjør også at varmeelementet bli slått på så rask temperaturen faller under $5\,^{\circ}\mathrm{C}$.

På koblingsbrettet i kabinettet finner du kretsene til sensorene. Alt av ledninger fra mikrokontrolleren og sensorene er koblet sammen på dette koblingsbrettet bortsett fra strømforskyingene til vindsensorene. Disse kobles sammen i sukkerbiten. Dette for å skille mellom kretsene på 5V og 24V. 

Ledningene fra sensorene kommer inn i bunnen av kabinettet. Isolasjonen rundt ledningene følger helt inn i kabinettet og er ikke avisolert mer enn at ledningene når sine innganger på koblingsbrettet og i sukkerbiten . Alt av komponenter og ledninger på koblingsbretter er loddet fast. 

Kabelen som leder 230V inn i kabinettet er ført inn helt til høyre. Dette for å isolere den best mulig bort fra sensorledningene. Her følger isolasjonen et godt stykke inn. Som du ser på figur \ref{fig:innredning} går den inn bak grenuttaket før den avmantles og kobles til grenuttaket. Dette har vi gjort ved å koble de sammen i en sukkerbit som er beskyttet av en kapsel.  

\subsection{Problemer underveis}
\label{subsec:monteringProblemer}
Før vi isolerte kabinettet med isopor, brukte vi et materialet av elastisk plastikk. Grunnet isolasjonens elastiske egenskap gjorde det enkelt å få de utskjærte platene hele inn i kabinettet. I motsetning til isoporen som vi var nødt til å dele i mindre biter for å få på plass. Isolasjonen hadde god isolasjonsevne mot kulde, men når det kom til varme viste det seg å absorbere fremfor å isolere. Dette medførte at vi valgte isopor som isolasjon selvom den var litt mer trøblete å få inn i kabinettet.

Før vi reiste opp til Hessdalen for å montere værstasjonen opplyste oppdragsgiver oss om at nettverksforbindelsen mellom hoved- og sekundærstasjonen er brutt. Nettverksforbindelsen går i en fiberkabel. Årsaken til brudd på forbindelsen var at et dyr hadde tygget i stykker kabelen. Oppdragsgiver fikk tak i en reparatør, men grunnet dårlige værforhold måtte reparasjonen utsettes. Dette gjør at værstasjonen vi monterte ved sekundærstasjonen ikke får sendt målingene sine til serveren før netterverksforbindelsen har blitt reparert.   
  

\section{Programvare}
\meta{Kort intro}
\subsection{Ethernut 2.1}
\label{subsec:Ethernut}

\subsubsection{Implementasjon av grensesnitt mot BMP180}
BMP180 benytter I\textsuperscript{2}C/TWI for kommunikasjon med mikrokontrolleren. Dette er en egen maskinvaremodul på mikrokontrolleren, som aksesseres gjennom dataregister. Disse registrene er dokumentert i databladet til mikrokontrolleren, og vi må benytte oss av disse fire:
\begin{itemize}
\item TWI Bit Rate Register (TWBR)

Brukes sammen med TWSR for å sette klokkefrekvensen i master-modus.
\begin{figure}[H]
	\centering
    \includegraphics[width=1\textwidth]{twi_twbr}
	\caption{TWBR fra datablad}
\end{figure}
\item TWI Control Register (TWCR)

Brukes for å kontrollere TWI-modulen. Her er vi interessert i bit 5, som sender START ut på bussen. Bit 4, som sender STOPP og bit 2 som aktiverer TWI-modulen.
\begin{figure}[H]
	\centering
    \includegraphics[width=1\textwidth]{twi_twcr}
	\caption{TWCR fra datablad}
\end{figure}
\item TWI Status Register (TWSR)

Bit 7-3 brukes for å sjekke status på TWI-modulen. Bit 1-0 er brukt til å skalere klokkefrekvensen.
\begin{figure}[H]
	\centering
    \includegraphics[width=1\textwidth]{twi_twsr}
	\caption{TWSR fra datablad}
\end{figure}
\item TWI Data Register (TWDR)

I transmit-modus, holder dette registeret på neste byte som skal sendes. I recieve-modus vil dette registeret inneholde data som ble mottatt.
\begin{figure}[H]
	\centering
    \includegraphics[width=1\textwidth]{twi_twdr}
	\caption{TWDR fra datablad}
\end{figure}
\end{itemize}

Før vi benytter oss av TWI-modulen må vi først initialisere den. Dette gjøres ved å først sette klokkefrekvensen. Klokkefrekvensen regner vi ut med formelen:

\begin{equation}
SCL\ frekvens = \frac{CPU\ Klokkefrekvens}{16+2\times TWBR\times 4^{TWPS}}
\end{equation}

Mikrokontrollerens CPU kjører på 14.7456 MHz\cite{nettside:EthernutHardwareManual}. Her velger vi TWBR til 17 og TWPS til 1:

\begin{verbatim}
    TWSR = (0<<TWPS1) | (0<<TWPS0); //Setter prescalar til 1.
    TWBR = (1<<TWBR4) | (1<<TWBR0); //Setter bit rate til 17.
\end{verbatim}

 Frekvensen havner da på cirka 97 kHz. Vi valgte denne frekvensen fordi kommunikasjon ved høyere frekvenser kan bli påvirket av støy og  avstanden kan også bli redusert\cite{nettside:I2CFAQ}. Vår applikasjon er heller ikke tidskritisk, vi skal kun benytte sensoren hvert 30. sekund.

Deretter starter vi TWI-modulen ved å skrive til TWCR:
\begin{verbatim}
    TWCR = (1<<TWEN); //Aktiverer TWI.
\end{verbatim}

Når vi skal kalkulere lufttrykket må vi først lese av kalibreringsparametere som er lagret på sensorens EEPROM(Electrically Erasable Programmable Read-Only Memory). Som vi ser på figur \ref{figure:bmp180_kalibreringsparametere} er dette elleve 16-bits registere som befinner seg på adresse 0xAA til og med 0xBF.

\begin{figure}[H]
	\centering
    \includegraphics[height=0.6\textwidth]{bmp180_kalibreringsparametere}
	\caption{Kalibreringsparametere på BMP180}
    \label{figure:bmp180_kalibreringsparametere}
\end{figure}

For å lese ut disse dataene må vi først sende ut START på bussen, det gjør vi med registeret TWCR:

\begin{verbatim}
    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN); //Sender START.
    //Venter på at TWINT er satt.
    while((TWCR & (1<<TWINT)) == 0) {
        ...
    }
    //START har blitt send.
\end{verbatim}

Så må vi sende adressen til hvilken enhet vi vil kommunisere med. Det gjøres ved å laste inn adressen inn i TWDR, for så å starte sending med TWCR:

\begin{verbatim}
    //Laster byten inn i data-registeret. Klar for sending.
    TWDR = data;
    
    //Starter sending av data i TWDR.
    TWCR = (1<<TWINT) | (1<<TWEN);
    
    //Venter på at TWINT er satt.
    while((TWCR & (1<<TWINT)) == 0) {
        ...
    }
    //Data har blitt sendt.
\end{verbatim}

BMP180 befinner seg på adresse 0xEE for skriving, og 0xEF for lesing\cite{nettside:DatasheetBMP180} Deretter sender vi hvilken adresse vi vil lese av. BMP180 vil da svare med verdien i registeret.

STOP sender vi når vi er ferdig med å kommunisere, ved å skrive til TWCR:

\begin{verbatim}
    TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN); //Sender STOP.
\end{verbatim}

Etter vi har mottatt og lagret alle kalibreringsparametere må vi sende en kommando til BMP180 som starter lesing av lufttrykk og temperatur. Grunnen til at vi også må lese temperatur er at den er en faktor i utregningen av lufttrykket. Fra figur \ref{figure:BMP180Tidsbruk} kan vi se at verdien 0x2E må skrives til kontrollregisteret 0xF4 for å måle temperatur. BMP180 vil da bruke minst 4.5ms på å fullføre målingen. Når BMP180 har gjort seg ferdig, vil rådata ligge i registeret 0xF6:

Når vi skal lese av rådata for lufttrykket må vi også velge hvilken nøyaktighet vi ønsker. Dette er bestemt av OSS(Oversampling Setting) som er et tall mellom 0-3. Som vi ser på figur ~\ref{figure:BMP180Tidsbruk} bruker BMP180 lengre tid på å måle når vi ønsker bedre nøyaktighet.

\begin{figure}[H]
	\centering
    \includegraphics[width=0.75\textwidth]{bmp180_oss_time}
	\caption{Tidsbruk for BMP180}
    \label{figure:BMP180Tidsbruk}
\end{figure}

Vi har valgt å benytte OSS=3 for best nøyaktighet. Det innebærer av vi må skrive verdien 0xF4 til kontrollregisteret 0xF4 og vente i minst 25.5 ms før vi leser 2 byte fra registeret 0xF6. Siden vi har valgt best nøyaktighet er det også en ekstra byte tilgjengelig i registeret 0xF8. Denne råverdien blir en del av en rekke utregninger som er beskrevet detaljert i datablad.

\subsubsection{Implementasjon av grensesnitt mot SHT10}
\meta{Litt om hvordan kommunikasjon foregår i detalj, ta med hvilke kommandoer som gjør hva. Sleng med bilder av komm. Noen eksempler}
Kommunikasjon med SHT10 må implementeres med bit banging. \cite{nettside:DatasheetSHT10}

\subsubsection{Implementasjon av ADC}
\meta{Kort om register for å styre/lese av ADC}

\subsubsection{Implementasjon av nettverk}
\meta{Hvordan nettverket blir tatt i bruk med NutOS, hvordan man henter ut tid fra NTP-server. Bruk av tråd for å sende }

\subsubsection{Implementasjon av hovedløkke}
\meta{Hvordan hele applikasjonen er satt sammen. Skjema over hele gangen i hovedløkken.}

\subsection{Serverside}
For å ta imot TCP-pakkene med JSON-formatert data og legge det inn i databasen, var vi avhengig av å ha en server kjørende på skolens nettverk. Denne serveren valgte vi som beskrevet i \ref{subsec:Serversiden} å bygge på Java\cite{nettside:java}.

\subsubsection{Pakkemottak og tråder}
For å kunne motta datapakkene værstasjonen sender fra Hessdalen og ned til skolens server, bruker vi Sockets. Nærmere bestemt «TCP Stream Sockets»\cite{nettside:streamsockets}. Disse tillater pålitelig to-veis kommunikasjon mellom både værstasjonen og serveren. Dette fungerer i praksis slik at serveren venter til en tilkobling er gjort, og data mottatt før den behandler data slik beskrevet under, og sender «Done» tilbake til værstasjonen. Når serveren er ferdig med dette, er den klar til å motta ny data. Dette måtte imidlertidig bli gjort trådbasert for at begge stasjonene skulle kunne sende på likt. Dermed gjorde vi det slik at så fort en ny tilkobling blir opprettet til serveren, lages det en egen tråd for å behandle denne tilkoblingen. Prosessen er den samme som beskrevet ovenfor, bortsett ifra at serveren kan håndere alle tilkoblinger selv om de kommer på likt.

\subsubsection{Konvertere JSON til SQL-spørringer}
Vi har laget en egen klasse kalt «DbManager» for å håndere den mottatte JSON-formaterte datastrengen og bygge SQL-spørringer innsetting i databasen. Her valgte vi å bruke et lite ressurskrevende bibliotek kalt Json-lib\cite{nettside:jsonlib}. Med dette biblioteket bygger vi et JSON-objekt av strengen, og kan med det lett hente ut målingsdata. Med dette bygger vi SQL-spørringer som kjøres ved hjelp av en klasse laget for å håndere databasen. Det er mer om denne prosessen i neste punkt.

\subsubsection{Databasebehandling}
Klassen «Db» har to oppgaver. Den første er å kjøre SQL-spørringene generert i «DbManager», og den andre er å returnere den autogenererte nøkkelen MySQL lager ved innsetting av data. Denne nøkkelen er svært viktig når det kommer til å få koblet riktige rader i databasen sammen og overholdt restriksjonene for fremmednøkler. Det er mer om databaseoppbygningen i (ref).

For at Java-serveren skal kunne koble seg til og håndere databasetilkoblinger, var vi avhengig av å bruke en driver fra MySQL kalt JDBC\cite{nettside:jdbc} (forkortelse for «Java Database Connectivity»). Dette er et slags bibliotek som utvider Java med muligheten for nettopp dette.   

\subsubsection{Kompilert JAR-fil}
Vi har valgt å kompilere den ferdige serveren som en JAR-fil. Dette er gjort i den hensikt å slippe å ha en relativt stor mengde klasser og biblioteker liggende løst der programmet skal kjøres fra. Ved å JAR-kompilere kan vi få med alle klasser og biblioteker i samme fil, og det blir dermed et mye mer ryddig produkt.

\subsubsection{Sikkerhet}
For at en «Network Socket» skal kunne ta imot tilkoblinger og data utenfor lokalnettet, må den relevante porten åpnes(ref) i router/brannmur for tilkoblinger utenfra. I enkelt tilfeller kan det være en sikkerhetsrisiko å ha porter åpne, men det er kun dersom programmet som mottar disse pakkene kan feiltolke innholdet og gjøre noe uforventet. Programmet vi har laget avviser alle pakker som ikke kommer med korrekt formatert JSON etter vår mal, så dette skal ikke være noe problem. Allikevel er det en dobbelsikring på plass. Porten vi bruker er nemlig kun åpnet for data fra de relevante IP-adressene værstasjonene sender fra. Det vil si at tilkoblinger på denne porten blir avvist fra alle andre adresser på internet. Av sikkerhetsårsaker nevner vi verken hvilken port eller hvilke IP-adresser dette gjelder.

\subsubsection{Cron}
Vi ønsket å garantere at serveren kjører til en hver tid. Vi har derfor tatt i bruk programmet cron. Cron er et program på *nix-operativsystemer som gjør det mulig å planlegge kjøring av et program/skript. Dette gjøres ved å skrive inn når og hva i en crontab(Cron tabell). Systemet vil da gjøre gitt oppgave på gitt tid.\cite{nettside:CrontabManPage} Vi har ført opp følgende linje i vår crontab på serveren:

\begin{verbatim}
59 * * * * /local/hessdalen/hessdalenweather/hws-make-run.sh
\end{verbatim}

Skriptet hws-make-run.sh vil da bli kjørt hver hele time på det 59. minuttet. Dette passer bra da mikrokontrolleren sender data hver hele time. Skriptet sjekker om vår server kjører, og starter den dersom den ikke gjør det:

\begin{verbatim}
#!/bin/bash
#hws-make-run.sh
#Passer på at HessdalenWeatherServer kjører.

program=hessdalen16.jar

if ps aux | grep -v grep | grep $program > /dev/null
    then
        exit
else
        java -jar $program & #Programmet kjører ikke, starter på nytt.
fi
exit
\end{verbatim}

\subsection{Datapresentasjon}
For å presentere måledata på hessdalen.org, valgte vi slik beskrevet i avsnitt \ref{subsec:visualisering} å lage \textbf{\gls{frontend}} på JavaScript, og \textbf{\gls{backend}} på PHP. Her går vi litt i dybden på hvilke ulike teknikker og metoder vi har brukt når vi bygde denne datapresentasjonen. I figur \ref{figure:jsDiagram} kan du se hvordan de ulike funksjonene i JavaScriptet kommuniserer sammen, og hvordan \textbf{\gls{backend}} og databasen jobber sammen med dette.
\begin{figure}[H]
	\centering
    \includegraphics[width=1\textwidth]{jsDiagram}
	\caption{Oversikt over hvordan de ulike funksjonene i JavaScriptet kommuniserer sammen, og med back-end.}
    \label{figure:jsDiagram}
\end{figure}

Det er mange skjermdumper av nettsiden for å beskrive dens oppbygging i dette avsnittet, men for å få den fulle opplevelsen og fortståelsen for hvordan siden fungerer, anbefales det at du besøker www.hessdalen.org og velger 'Været'('The weather' i den engelske versjonen) i menyen til venstre.

\subsubsection{Backend}
Selv om den største delen av fremvisningen ble bygd på JavaScript, så måtte vi også lage en \textbf{\gls{backend}} for å kommunisere med databasen. Grunnen til at dette er som beskrevet i avsnitt \ref{subsec:visualisering} at JavaScript er et språk som blir kompilert der og da av nettleseren. Med andre ord hadde tilkoblingsinformasjonen til databasen vært fritt tilgjengelig for alle som besøkte siden. For å omgå dette, måtte vi bruke et språk som kompileres på serversiden, og kildekoden dermed ikke fritt tilgjengelig. Vi valgte slik også beskrevet i avsnitt \ref{subsec:visualisering} å lage \textbf{\gls{backend}} i PHP.

Det denne koden gjør er å lese av de superglobale \textbf{\glslink{HTTP-variabler}{HTTP-variablene}} sendt gjennom linken, hente ut relevant måledata fra databasen og skrive ut JSON-formatert data på siden. Dette blir mye enklere å forstå hvis vist i praksis, så her er et eksempel:\\\\
Åpner «dbToJson.php» med denne URL:
\begin{verbatim}
dbToJson.php?type=temperature&from=2014-5-8%2000:00:00
&to=2014-5-8%2023:59:59&hoursOverride=false
\end{verbatim}
Her ser vi at datatype er satt til å være temperatur, fradato til 08.05.14 kl 00:00 og tildato til 08.05.14 kl 23:59. \\Verdien «hoursOverride» er her satt til å være falsk, da vi velger å bruke visningens standardinstillinger for restriktering av data (merk:  ettersom dette kun er èn dag her, er standard å vise alle målinger i tidsrommet satt). Dersom brukeren har valgt å kun vise måledata fra kl 00 og 06 ville det sett slik ut:
\begin{verbatim}
hoursOverride=true&hours00=true&hours06=true
&hours12=false&hours18=false
\end{verbatim}
Den første linken ovenfor henter dermed ut fra databasen og konverterer til JSON slik beskrevet ovenfor. Deretter skrives det ut og blir slik:
\begin{verbatim}
[
  {
    "logId_id":"12","time":"2014-05-08 00:00:00",
    "station":"2",
    "valueAvg":"0.6212805",
    "valueNow":"0.5",
    "valueMax":"1.220001","timeMax":"2014-05-07 23:01:00",
    "valueMin":"0.5","timeMin":"2014-05-07 23:57:30"
  },
  ...
  ...
  ...
  {
    "logId_id":"35","time":"2014-05-08 23:00:00",
    "station":"2",
    "valueAvg":"1.312188333333333",
    "valueNow":"1.18",
    "valueMax":"2.100002","timeMax":"2014-05-08 22:01:00",
    "valueMin":"1.18","timeMin":"2014-05-08 22:47:30"
  }
]
\end{verbatim}
(Merk: Dette ville egentlig blitt veldig mange målinger, så de er kuttet ned til å vise første og siste for lesbarhet. Prikkene mellom målingene indikerer der de andre ville vært.)\\\\
Det blir altså vist som en array av JSON-elementer. Dette blir senere tolket og brukt til presentering i JavaScript.

\textbf{\Gls{backend}} brukes også i første lasting av siden for å hente ut når første og siste måling ble gjort. Dette brukes for å begrense tilgjengelige datoer i kalenderene der brukeren velger tidsrom for datapresentasjon.

\subsubsection{Biblioteker brukt}
Dette er JavaScript-bibliotekene vi har tatt i bruk for å lage datapresentasjonen.
\begin{description}
  \item[jQuery\cite{nettside:jquery}] \hfill \\
  jQuery er et bibliotek laget for å simplifisere programmeringsprosessen. Mottoet deres er 'write less, do more', og gjengir ganske godt hva det går ut på. 
  I vår kode brukes primært jQuery for å forenkle AJAX-basert datalasting (beskrevet dypere i senere punkt), men også i enkelte for-løkker og andre småfunksjoner.
  \item[jQuery UI\cite{nettside:jqueryUI}] \hfill \\
  jQuery UI er et bibliotek som samhandler med jQuery for å tilby ulike visualiseringsløsninger. I vår kode brukes dette for bygge kalenderen der bruker kan velge tidsrom for datapresentasjon. 
  \item[Google Visualisation\cite{nettside:googlevis}] \hfill \\
  Google Visualisation er et bibliotek laget for visualisering av data gjennom grafer og diagrammer. I vår kode brukes dette for å generere linjediagrammet/linjegrafen for datapresentasjonen.
\end{description}

\subsubsection{Brukervalg}
I figur \ref{figure:brukervalg} vises de ulike valgene brukeren kan ta for å påvirke datapresentasjonen. 
\begin{figure}[H]
	\centering
    \includegraphics[width=0.7\textwidth]{brukervalg}
	\caption{Valgene presentert for brukeren.}
    \label{figure:brukervalg}
\end{figure}
Disse brukervalgene har blitt valgt på bakgrunn av to kriterier:
\begin{itemize}
\item Hovedfokus på å ikke overvelme brukeren, og heller vise de viktigste valgene uten at det skal gå for mye på bekostning av funksjonalitet. Et eksempel på dette, er at istedenfor at brukeren kan velge hvilke type verdier som skal vises (gjennomsnitt, maks og minimum), vises kun gjennomsnittsverdien grafisk, og de andre verdiene dersom man flytter musepekeren over en måling på grafen(slik vist i figur \ref{figure:grafiskfremvisning}).
\item Det andre vi har tatt hensyn til er hvilke ønsker arbeidsgiver hadde. Spesifikt innebar det muligheten til å vise måledata både grafisk og på tabellform, og å kunne spesifisere hvilke timer i døgnet det skal hentes ut fra.
\end{itemize}
For å sikre at ikke brukeren skal kunne gjøre noen feil når de velger, blir alle feltene sjekket hver gang det blir gjort en endring. Det vil si at brukeren kan for eksempel ikke huke bort alle timesvalgene uten at «Standard» blir automatisk huket på igjen. Lignende sikring er laget for stasjonsvalget. I kalenderen som åpnes når tekstfeltene markert «Fra» og «Til» trykkes, er det ikke mulig å verken velge datoer der det ikke er målinger (Altså før stasjone  ble montert, og etter nåtid). Det er heller ikke mulig å sette en senere fradato enn den valgte tildatoen. Alle disse sikringene kombinert, gjør at det er tilnærmet umulig å utføre brukerfeil.

\subsubsection{Dynamisk innholdslasting}
\meta{onChange}
Siden er bygd opp slik at brukeren aldri trenger å trykke noen dedikert knapp for å laste data. Så fort et brukervalg blir endret, oppdaterer datapresentasjonen seg selv for å reflektere de nye valgene. Dette sørger for en veldig dynamisk følelse på hele siden, og forbedrer brukeropplevelsen.

Måten dette har blitt oppnådd på, er ved å bruke en teknologi kalt \textbf{\Gls{ajax}}. Dette gjør det altså mulig for nettleseren å hente ny data fra \textbf{\gls{backend}} uten at selve siden må lastes på nytt. Det er mulig å lage \textbf{\Gls{ajax}}-basert datalasting i JavaScript uten noen ekstra bibliotker, men vi har valgt å bruke jQuery for å forenkle prosessen.

\subsubsection{Grafisk fremvisning}
For å ha muligheten til å vise frem måledata på graf-/diagramform, bestemte vi oss altså for å bruke biblioteket Google Visualisation. I dette biblioteket var det mange ulike måter å presentere data på, men vi bestemte oss for å bruke linjedigram da dette er den meste konvensjonelle og oversiktlige måten å presentere værdata på. Slik beskrevet i punktet om 'Brukervalg' ovenfor, står brukeren ganske fritt til å velge hvilke målinger som skal vises i diagrammet. X-aksen på diagrammet viser tid, og Y-aksen viser målingsverdi. Google Visualisation sørger for at akseverdiene justerer seg til de mest praktiske verdiene. Med det menes det at dersom man for eksempel kun har temperaturmålinger mellom 20 og 25 grader i tidsrommet valgt, vil verdiene på Y-aksene justere seg for å best reflektere dette. Dersom brukeren velger et stort tidsrom, reduseres antall målinger vist om dagen slik:
\begin{description}
  \item[1-10 dager] \hfill \
  \begin{itemize}
    \item Standard: Alle målinger vises(24 i døgnet).
    \item Brukervalg: Kan vise alle fire (kl 00, 06, 12 og 18).
  \end{itemize}
  \item[11-30 dager] \hfill \
  \begin{itemize}
    \item Standard: To målinger i per døgn vises (kl 06 og 12).
    \item Brukervalg: Kan vise alle fire (kl 00, 06, 12 og 18).
  \end{itemize}
  \item[Over 30 dager] \hfill \
  \begin{itemize}
    \item Standard: En måling per døgn (kl 12).
    \item Brukervalg: Kan vise èn av fire (kl 00, 06, 12 og 18).
  \end{itemize}  
\end{description}
Hovedgrunnene til at intervallet mellom målingene må begrenses i grafisk visning er at lesbarheten vil gå ned, og datakraften nødvendig vil gå opp ved for mange punkter vist.

På figur \ref{figure:grafiskfremvisning} kan du se hvordan det ser ut når alle temperaturmålinger mellom 8. mai og 14. mai vises.
\begin{figure}[H]
	\centering
    \includegraphics[width=0.7\textwidth]{grafiskfremvisning}
	\caption{Måledata for temperatur presentert med linjediagram.}
    \label{figure:grafiskfremvisning}
\end{figure}

\subsubsection{Tabellvisning}
Tabellvisningen (vist i figur \ref{figure:tabellvisning} er bygd dynamisk av JavaScriptet på vanlige HTML-tabeller basert på hvilken måledata som skal vises. Denne tabellen erstatter diagrammets plass på siden når brukeren velger å vise måledata på tabellform.

Å vise data på denne måten, begrenser ikke antall målinger hentet ut fra databasen dersom «Standard»-verdien er satt, uansett tidsrom. Vi har valgt å gjøre det slik, da det å vise en tabell ikke krever nevneverdig mer av maskinen eller reduserer lesbarheten, samme hvor mange målinger som vises. Du kan forøvrig fremdeles velge å begrense hvilke timer måledata skal vises fra selv.
\begin{figure}[H]
	\centering
    \includegraphics[width=0.7\textwidth]{tabellvisning}
	\caption{Måledata for temperatur presentert på tabellform.}
    \label{figure:tabellvisning}
\end{figure}

\subsubsection{Praktisk informasjon}
For å gi brukeren litt praktisk informasjon om værstasjonene, har vi laget en egen boks (se figur \ref{figure:praktiskInformasjon} på siden dedikert til nettopp dette. Her er det beskrevet når stasjonene ble montert, hvor de står og litt informasjon om hvordan den grafiske fremvisningen begrenses av størrelsen på tidsrommet.
\begin{figure}[H]
	\centering
    \includegraphics[width=0.4\textwidth]{beskrivelsenorsk}
	\caption{Praktisk informasjon om værstasjonene vist på siden.}
    \label{figure:praktiskInformasjon}
\end{figure}

\subsubsection{Feilhåndering}
Her var målet å skrive koden med så god feilhåndtering at ingenting skal stoppe opp selv om det mangler hele målinger eller er uhåndterbare verdier i databasen. I tillegg til dette har fokuset vært å gjøre opplevelsen av presentasjonsdataen god, selv om noe slikt skulle oppstå. Ettersom stasjon 2 ikke er i stand til å sende værdata før den får nettverk igjen (se avsnitt \ref{subsec:monteringProblemer}), har vi et godt eksempel på dette i figur \ref{figure:grafiskfremvisning}.

Dersom JavaScriptet skulle få problemer med å hente ut data produsert av «backend» pga. av treg databasetilkobling, eller lignende, får brukeren beskjed om det. Denne beskjeden lyder som følger «Tidsavbrudd. Fortsetter å prøve...». Så fort tilkoblingen er gjenopprettet, vises data slik brukeren ba om.

\subsubsection{Design}
Hovedfokuset her har vært å lage en side som er oversiktlig og lett å bruke. Slik beskrevet i punktet om 'Brukervalg' ovenfor, skal det heller ikke være nødvendig å måtte bruke tid på å forstå hvordan siden skal brukes.

Videre har vi valgt et design som skal være enkelt, men appellerende for brukeren. Slik vist på figur \ref{figure:fullSide}, er siden delt inn i tre områder:
\begin{description}
  \item[Brukervalg] \hfill \
  \begin{itemize}
    \item Plassering: Nederste på siden.
    \item Formål: La brukeren påvirke hvilke data som skal vises.
  \end{itemize}
  \item[Datafremvisning] \hfill \
  \begin{itemize}
    \item Plassering: Til venstre på siden.
    \item Formål: Fremvise måledata enten via diagram eller tabell.
  \end{itemize}
  \item[Informasjon] \hfill \
  \begin{itemize}
    \item Plassering: Til høyre på siden.
    \item Formål: Vise praktisk informasjon i sammenheng med værstasjonene.
  \end{itemize}
\end{description}
\begin{figure}[H]
        \centering
        \begin{subfigure}[H]{0.46\textwidth}
                \includegraphics[width=\textwidth]{fullSide}
                \caption{Med linjediagram}
                \label{figure:fullSideDiagram}
                \quad
        \end{subfigure}
        \begin{subfigure}[H]{0.52\textwidth}
                \includegraphics[width=\textwidth]{fullSideTabell}
                \caption{Med tabell}
                \label{figure:fullSideTabell}
                \quad
        \end{subfigure}
        \caption{Det ferdige designet på siden med de ulike metodene for å vise data.}
        \label{figure:fullSide}
\end{figure}
For å få til dette i praksis, har vi brukt CSS3\cite{nettside:css3}, som er en \textbf{\glslink{stilark}{stilarkteknologi}}. Hele designet er bygd ved hjelp av denne teknologien.
\subsubsection{Engelsk versjon}
Oppdragsgivers nettside www.hessdalen.org er tilgjengelig på både Norsk og Engelsk. Dette innbar at vi måtte lage en engelsk versjon av datafremvisningen også. For å lage denne, ble vi nødt til å oversette flere variabler og strenger i JavaScriptet, og teksten skrevet i HTML-filen.

Alle figurene i dette avsnittet er hentet fra den Norske versjonen av siden, men den Engelske versjonen ligger også fritt tilgjengelig på www.hessdalen.org.

\subsubsection{Sikkerhet}
Det eneste sikkertsaspektet vi har måtte ta hensyn til i denne koden, er såkalt 'SQL-injection'. Det vil si at noen kan prøve å bruke «backend» til å sende inn ondsinnede spørringer til databasen. Som for eksempel å avslutte en streng (semikolon) sendt til databasen og følge opp med en 'DROP TABLE...'-setning. Dette har vi sikret oss mot ved å ta i bruk funksjonen 'mysql\underline{\hspace{.07in}}real\underline{\hspace{.07in}}escape\underline{\hspace{.07in}}string'\cite{nettside:phpescape} i PHP. Denne sørger for at det blir lagt på en '\textbackslash' foran tegn MySQL kan tolke. Slik blir de gjort ubrukelige, og 'SQL-injection' umulig.

\subsubsection{Implementasjon på hessdalen.org}
Da vi var ferdig med produksjonen av datafremvisningen, skulle den implementeres på www.hessdalen.org. Dette ble gjort i tett samarbeid med oppdragsgiver, og det eneste utfordringen vi støtte på var en CSS-konflikt der siden vår overstyrte stilsettet på www.hessdalen.org sine tabeller. Dette ble raskt løst ved å sette spesifikke ID'er på tabellene i datapresentasjonen.
\begin{figure}[H]
	\centering
    \includegraphics[width=1\textwidth]{implementertsystem}
	\caption{Den norske versjon av datapresentasjon implementert på hessdalen.org}
    \label{figure:implementertsystem}
\end{figure}

\subsubsection{Arbeidsprosessen}
\meta{Hvilken rekkefølge ble ting gjort i? Stikkord: Hva vi begynte med, osv. Input fra arbeidsgiver}

\subsubsection{Problemer underveis}
\meta{Var det noen problemer? Hvis så, hvilke? Stikkord: Ikke all info i Google Visualisation API(ref) var helt oppdatert og mer tidkrevende enn antatt.}

\section{Arbeidsprosessen}
\meta{Si noe om hvordan vi har jobbet som gruppe. Arbeidsfordeling. Habbla Habbla.}