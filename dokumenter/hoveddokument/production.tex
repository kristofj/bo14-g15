%\cleardoublepage
\chapter{Produksjon}
\label{chap:production} 

I dette kapittelet vil vi ta for oss hvordan vi har produsert resultatene i proskjetet og beskrive selve produktet. Vi tar med hvilke verktøy vi har brukt, hvordan produksjonen foregikk, delegering av oppgaver og hvordan vi har løst problemer som har oppstått.

\section{Maskinvare}
\label{sec:HardwareDelen}

\meta{Ting å nevne: jobbet på verkstedet på skolen.. etc.. loddet sammen komponenter, bygd deksel og beskyttelse til sensorene.} \\

\subsection{Tilpassing for montering i felt}

Vi har laget to værstasjoner som skal monteres på to forskjellige steder. Den ene skal festes til en mast ved hovedstasjonen og den andre skal festes til et tre ved sekundærstasjonen.
\subsubsection{Vindsensorene}
Som tilbehør til vindsensorene fikk vi tak i en monteringsstang, vist i figur \ref{fig:monteringsstang}, fra samme produsent som er beregnet for disse sensorene. Sensorene festes og løsnes enkelt fra monteringsstangen ved å skru på to låseskiver som sitter rett over lendningen ut fra sensorene. Selve monteringsstangen festes til ønsket plass ved hjelp av to metallbånd og tilhørende låsemekanisme. 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.50\textwidth]{zmo40}
  \caption{Monteringsstang for vindsensorene}
  \label{fig:monteringsstang}
\end{figure}
\subsubsection{BMP180}
\label{subsubsec:hardwarebmp180}
Lufttrykksensoren BMP180 ble vi nødt til å montere i en koblingsboks da den ikke har noen form for beskyttelsesetui. Dette ble gjort ved å lodde fast sensoren til et koblingsbrett som ble skrudd fast inne i koblingsboksen. For å sikkre en tett kabelgjennomføring benyttet vi kabelnipler. Sensoren er også avhengig av luftgjennomstrøming i boksen for korrekt avlesning av lufttrykket. Dette ble løst ved å lage et lite hull i siden og et i bunnen for drenering av vann som kan renne inn.

Festeanordningen til luftrykksensoren ved hovedstasjonen lagde vi av et bøybart metallbånd med hull i. Dette ble festet til boksen og deretter til masten ved å bøye metallbåndet rundt soltpene i masten og skru det fast med maskinskruer. Ved sekundærstasjonen ble boksen festet rett til treet ved bruk av treskruer. Dette ser du på figur \ref{fig:ferdigmontert} i avsnitt \ref{subsec:tilpassing}.

\subsubsection{SHT10}
For at temperaturmålingene ikke skal bli påvirket av direkte sollys har vi valgt å feste sensoren i en hvit koblingsboks. Koblingsboksen har tillstrekklig med åpninger for gjennomlufting slik at luften inne i boksen holder samme temperatur som på utsiden. Måten den er montert ved de to stasjonene er gjort på samme vis som ved BMP180, beskrevet i avsnittet ovenfor. 

\subsection{Tilpassing av kabinettet}
\label{subsec:tilpassing}

Det vi valge å bruke som kabinett på værstasjonen er et skap av stål med beskyttelsesgrad IP 66. Dette er mer en tilstrekkelig for utendørs montering. Vi har også gjort ett par tillegsmodifikasjoner. Innvendig har vi isolert det med isopor og montert en termostat som styrer et varmeelement for å forhindre kondes og frost. Termostaten slår på varmeelementet ved  $5\,^{\circ}\mathrm{C}$ og av ved $15\,^{\circ}\mathrm{C}$.

Komponentene som skal huses i kabinettet er skrudd fast i tilhørende monterinsplate som fulgte med kabinettet. Selve festeanordningen til kabinettetene for å feste de ved hovedstasjon og sekundærstasjonen er laget av metallbånd med skruehull. På figur \ref{fig:ferdigmontert}  ser du hvordan dette ble gjort. 

\begin{figure}[H]
        \centering
        \begin{subfigure}[H]{0.45\textwidth}
                \includegraphics[width=\textwidth, angle = 90]{hovedstasjon}
                \caption{Hovedstasjon}
                \label{fig:hovedstasjon}
                \quad
        \end{subfigure}
        \begin{subfigure}[H]{0.45\textwidth}
                \includegraphics[width=\textwidth]{stasjon2}
                \caption{Sekundærstasjon}
                \label{fig:sekundstasjon}
                \quad
        \end{subfigure}
        \caption{Værstasjonene montert ved målestasjonene}\label{fig:ferdigmontert}
\end{figure}

\subsubsection{Innredning i kabinettet}

I figur \ref{fig:innredning} ser du hvordan vi har innredet kabinettet. Vi har tatt høyde for at kablene til strømforskyningene kan fåresake støy som kan påvirke avlesningen av sensorene. Defor har vi lagt disse mest mulig utenom mikrokontrolleren, koblingsbrettet og sensorledningene.   

\begin{figure}[H]
	\centering
    \includegraphics[width=\textwidth]{innredning}
    \caption{Innredning i kabinettet}
  	\label{fig:innredning}
\end{figure}

Varmeelementet er festet til en trekloss i lokket fremfor direkte til monteringsstripa i lokket. Slik unngår vi varmetapet som hadde oppstått om vi hadde festet det direkte til monteringsstripa. Denne plasseringen var også den mest taktiske for å unngå at strålingsvarmen fra elementet kan komme til å smelte i stykker komponenter rundt, og for å få plassert det så lavt som mulig.

Termostaten, som styrer varmeelementet, er festet lavt i sideveggen på motsatt side av varmeelementet og strømforskyningene. Dette for å unngå at det blir påvirket av andre faktorer enn luften inne i kabinettet og fordi det er her det blir lavest temperatur.

På koblingsbrettet i kabinettet finner du kretsene til sensorene. Alt av ledninger fra mikrokontrolleren og sensorene er koblet sammen på dette koblingsbrettet bortsett fra strømforskyingene til vindsensorene. Disse koblet sammen i sukkerbiten. Dette for å skille på 5V og 24V. 

Ledningene fra sensorene kommer inn i bunnen av kabinettet. Isolasjonen rundt ledningene følger helt inn i kabinettet og er ikke terminert bort mer enn at ledningene når sine innganger på koblingsbrettet og i sukkerbiten. Kabelen som leder 230V inn i kabinettet er ført inn helt til høyre. Dette for å isolere best mulig bort fra sensorledningene. Her følger isolasjonen et godt stykke inn. Som du ser på figur \ref{fig:innredning} går den inn bak grenuttaket før den termineres til grenuttaket.

\subsection{Problemer underveis}

Før vi isolerte kabinettet med isopor, brukte vi et materialet av elastisk plastikk. Grunnet isolasjonens elastiske egenskap gjorde det enkelt å få de utskjærte platene hele inn i kabinettet. I motsetning til isoporen som vi var nødt til å dele i mindre biter for å få inn. Isolasjonen hadde god isolasjonsevne mot kulde, men når det kom til varme viste det seg å absorbere fremfor å isolere. Dette medførte at vi valgte isopor som isolasjon selvom den var litt mer trøblete å få inn i kabinettet.
  

\section{Programvare}
\meta{Kort intro}
\subsection{Ethernut 2.1}
\label{subsec:Ethernut}

\subsubsection{Implementasjon av grensesnitt mot BMP180}
BMP180 benytter I\textsuperscript{2}C/TWI for kommunikasjon med mikrokontrolleren. Dette er en egen maskinvaremodul på mikrokontrolleren, som aksesseres gjennom dataregister. Disse registrene er dokumentert i databladet til mikrokontrolleren, og vi må benytte oss av disse fire:
\begin{itemize}
\item TWI Bit Rate Register (TWBR)

Brukes sammen med TWSR for å sette klokkefrekvensen i master-modus.
\begin{figure}[H]
	\centering
    \includegraphics[width=1\textwidth]{twi_twbr}
	\caption{TWBR fra datablad}
\end{figure}
\item TWI Control Register (TWCR)

Brukes for å kontrollere TWI-modulen. Her er vi interessert i bit 5, som sender START ut på bussen. Bit 4, som sender STOPP og bit 2 som aktiverer TWI-modulen.
\begin{figure}[H]
	\centering
    \includegraphics[width=1\textwidth]{twi_twcr}
	\caption{TWCR fra datablad}
\end{figure}
\item TWI Status Register (TWSR)

Bit 7-3 brukes for å sjekke status på TWI-modulen. Bit 1-0 er brukt til å skalere klokkefrekvensen.
\begin{figure}[H]
	\centering
    \includegraphics[width=1\textwidth]{twi_twsr}
	\caption{TWSR fra datablad}
\end{figure}
\item TWI Data Register (TWDR)

I transmit-modus, holder dette registeret på neste byte som skal sendes. I recieve-modus vil dette registeret inneholde data som ble mottatt.
\begin{figure}[H]
	\centering
    \includegraphics[width=1\textwidth]{twi_twdr}
	\caption{TWDR fra datablad}
\end{figure}
\end{itemize}

Før vi benytter oss av TWI-modulen må vi først initialisere den. Dette gjøres ved å først sette klokkefrekvensen. Klokkefrekvensen regner vi ut med formelen:

\begin{equation}
SCL\ frekvens = \frac{CPU\ Klokkefrekvens}{16+2*TWBR*4^{TWPS}}
\end{equation}

Mikrokontrollerens CPU kjører på 14.7456 MHz\cite{nettside:EthernutHardwareManual}. Her velger vi TWBR til 17 og TWPS til 1:

\begin{verbatim}
TWSR = (0<<TWPS1) | (0<<TWPS0); //Setter prescalar til 1.
TWBR = (1<<TWBR4) | (1<<TWBR0); //Setter bit rate til 17.
\end{verbatim}

 Frekvensen havner da på cirka 97 kHz. Vi valgte denne frekvensen fordi kommunikasjon ved høyere frekvenser kan bli påvirket av støy og  avstanden kan også bli redusert\cite{nettside:I2CFAQ}. Vår applikasjon er heller ikke tidskritisk, vi skal kun benytte sensoren hvert 30. sekund.

Deretter starter vi TWI-modulen ved å skrive til TWCR:
\begin{verbatim}
TWCR = (1<<TWEN); //Aktiverer TWI.
\end{verbatim}

Når vi skal kalkulere lufttrykket må vi først lese av kalibreringsparametere som er lagret på sensoren EEPROM(Electrically Erasable Programmable Read-Only Memory). Dette er elleve 16-bits registere som befinner seg på adresse 0xAA til og med 0xBF.

\begin{figure}[H]
	\centering
    \includegraphics[height=0.6\textwidth]{bmp180_kalibreringsparametere}
	\caption{Kalibreringsparametere på BMP180}
\end{figure}

For å lese ut disse dataene må vi først sende ut START på bussen, før vi sender adressen til hvilken enhet vi vil kommunisere med. BMP180 befinner seg på adresse 0xEE for skriving, og 0xEF for lesing.\cite{nettside:DatasheetBMP180} Deretter sender vi hvilken adresse vi vil lese av. BMP180 vil da svare med verdien i registeret.

Etter vi har mottatt og lagret alle kalibreringsparametere må vi sende en kommando til BMP180 som starter lesing av lufttrykk og temperatur. Grunnen til at vi også må lese temperatur er at den er en faktor i utregningen av lufttrykket. Som vi ser på figur \ref{figure:BMP180Tidsbruk} må vi skrive verdien 0x2E til kontrollregisteret 0xF4 for å måle temperatur. Vi må da vente i minst 4.5 ms. Når BMP180 har gjort seg ferdig, vil rådata ligge i registeret 0xF6.

Når vi skal lese av rådata for lufttrykket må vi også velge hvilken nøyaktighet vi ønsker. Dette er bestemt av OSS(Oversampling Setting) som er et tall mellom 0-3. Som vi ser på figur ~\ref{figure:BMP180Tidsbruk} bruker BMP180 lengre tid på å måle når vi ønsker bedre nøyaktighet.

\begin{figure}[H]
	\centering
    \includegraphics[width=0.75\textwidth]{bmp180_oss_time}
	\caption{Tidsbruk for BMP180}
    \label{figure:BMP180Tidsbruk}
\end{figure}

Vi har valgt å benytte OSS=3 for best nøyaktighet. Det innebærer av vi må skrive verdien 0xF4 til kontrollregisteret 0xF4 og vente i minst 25.5 ms før vi leser av registeret 0xF6. Slik vil det se ut når vi ønsker å lese råverdien for lufttrykk.

\meta{Hvordan man bruker dataregister på mikrokontrolleren for I2C. Hvilke adresser som brukes på BMP180}
\subsubsection{Implementasjon av grensesnitt mot SHT10}
\meta{Litt om hvordan kommunikasjon foregår i detalj, ta med hvilke kommandoer som gjør hva ++}

\subsubsection{Implementasjon av ADC}
\meta{Kort om register for å styre/lese av ADC}

\subsubsection{Implementasjon av nettverk}
\meta{Hvordan nettverket blir tatt i bruk med NutOS, hvordan man henter ut tid fra NTP-server. Bruk av tråd for å sende }

\subsubsection{Implemtasjon av hovedløkke}
\meta{Hvordan hele applikasjonen er satt sammen. Skjema over hele gangen i hovedløkken.}

\subsection{Serverside}
For å ta imot TCP-pakkene med JSON-formatert data og legge det inn i databasen, var vi avhengig av å ha en server kjørende på skolens nettverk. Denne serveren valgte vi som beskrevet i \ref{subsec:Serversiden} å bygge på Java\cite{nettside:java}.

\subsubsection{Pakkemottak og tråder}
For å kunne motta datapakkene værstasjonen sender fra Hessdalen og ned til skolens server, bruker vi Sockets. Nærmere bestemt «TCP Stream Sockets»\cite{nettside:streamsockets}. Disse tillater pålitelig to-veis kommunikasjon mellom både værstasjonen og serveren. Dette fungerer i praksis slik at serveren venter til en tilkobling er gjort, og data mottatt før den behandler data slik beskrevet under, og sender «Done» tilbake til værstasjonen. Når serveren er ferdig med dette, er den klar til å motta ny data. Dette måtte imidlertidig bli gjort trådbasert for at begge stasjonene skulle kunne sende på likt. Dermed gjorde vi det slik at så fort en ny tilkobling blir opprettet til serveren, lages det en egen tråd for å behandle denne tilkoblingen. Prosessen er den samme som beskrevet ovenfor, bortsett ifra at serveren kan håndere alle tilkoblinger selv om de kommer på likt.

\subsubsection{Konvertere JSON til SQL-spørringer}
Vi har laget en egen klasse kalt «DbManager» for å håndere den mottatte JSON-formaterte datastrengen og bygge SQL-spørringer innsetting i databasen. Her valgte vi å bruke et lite ressurskrevende bibliotek kalt Json-lib\cite{nettside:jsonlib}. Med dette biblioteket bygger vi et JSON-objekt av strengen, og kan med det lett hente ut målingsdata. Med dette bygger vi SQL-spørringer som kjøres ved hjelp av en klasse laget for å håndere databasen. Det er mer om denne prosessen i neste punkt.

\subsubsection{Databasebehandling}
Klassen «Db» har to oppgaver. Den første er å kjøre SQL-spørringene generert i «DbManager», og den andre er å returnere den autogenererte nøkkelen MySQL lager ved innsetting av data. Denne nøkkelen er svært viktig når det kommer til å få koblet riktige rader i databasen sammen og overholdt restriksjonene for fremmednøkler. Det er mer om databaseoppbygningen i (ref).

For at Java-serveren skal kunne koble seg til og håndere databasetilkoblinger, var vi avhengig av å bruke en driver fra MySQL kalt JDBC\cite{nettside:jdbc} (forkortelse for «Java Database Connectivity»). Dette er et slags bibliotek som utvider Java med muligheten for nettopp dette.   

\subsubsection{Kompilert JAR-fil}
Vi har valgt å kompilere den ferdige serveren som en JAR-fil. Dette er gjort i den hensikt å slippe å ha en relativt stor mengde klasser og biblioteker liggende løst der programmet skal kjøres fra. Ved å JAR-kompilere kan vi få med alle klasser og biblioteker i samme fil, og det blir dermed et mye mer ryddig produkt.

\subsubsection{Sikkerhet}
For at en «Network Socket» skal kunne ta imot tilkoblinger og data utenfor lokalnettet, må den relevante porten åpnes(ref) i router/brannmur for tilkoblinger utenfra. I enkelt tilfeller kan det være en sikkerhetsrisiko å ha porter åpne, men det er kun dersom programmet som mottar disse pakkene kan feiltolke innholdet og gjøre noe uforventet. Programmet vi har laget avviser alle pakker som ikke kommer med korrekt formatert JSON etter vår mal, så dette skal ikke være noe problem. Allikevel er det en dobbelsikring på plass. Porten vi bruker er nemlig kun åpnet for data fra de relevante IP-adressene værstasjonene sender fra. Det vil si at tilkoblinger på denne porten blir avvist fra alle andre adresser på internet. Av sikkerhetsårsaker nevner vi verken hvilken port eller hvilke IP-adresser dette gjelder.

\subsubsection{Crontab(ref)}
\meta{Kristoffa. U wanna write? Litt om hva, hvorfor og hvordan.}

\subsubsection{Problemer underveis}
\meta{Var det noen problemer? Hvis så, hvilke?}

\subsection{Datapresentasjon}
\meta{Kan Mikael skrive her hvordan du jobbet, og hvilken løsninger du hadde, og litt om koden? Kan sikkert ta med eksempelkode også}

\subsubsection{Backend}
Selv om den største delen av fremvisningen ble bygd på JavaScript, så måtte vi også lage en «backend» for å kommunisere med databasen. Grunnen til at dette er som beskrevet i \ref{subsec:visualisering} at JavaScript er et språk som blir kompilert der og da av nettleseren. Med andre ord hadde tilkoblingsinformasjonen til databasen vært fritt tilgjengelig for alle som besøkte siden. For å omgå dette, måtte vi bruke et språk som kompileres på serversiden, og kildekoden dermed ikke fritt tilgjengelig. Vi valgte slik også beskrevet i \ref{subsec:visualisering} å lage «backend» i PHP.

Det denne koden gjør er å lese av de superglobale HTTP-variablene(ref) sendt gjennom linken, hente ut relevant måledata fra databasen og skrive ut JSON-formatert data på siden. Dette blir mye enklere å forstå hvis vist i praksis, så her er et eksempel:\\\\
Åpner «dbToJson.php» med denne URL:
\begin{verbatim}
dbToJson.php?type=temperature&from=2014-5-8%2000:00:00
&to=2014-5-8%2023:59:59&hoursOverride=false
\end{verbatim}
Her ser vi at datatype er satt til å være temperatur, fradato til 08.05.14 kl 00:00 og tildato til 08.05.14 kl 23:59. \\Verdien «hoursOverride» er her satt til å være falsk, da vi velger å bruke visningens standardinstillinger for restriktering av data (merk:  ettersom dette kun er èn dag her, er standard å vise alle målinger i tidsrommet satt). Dersom brukeren har valgt å kun vise måledata fra kl 00 og 06 ville det sett slik ut:
\begin{verbatim}
hoursOverride=true&hours00=true&hours06=true
&hours12=false&hours18=false
\end{verbatim}
Den første linken ovenfor henter dermed ut fra databasen og konverterer til JSON slik beskrevet ovenfor. Deretter skrives det ut og blir slik:
\begin{verbatim}
[
  {
    "logId_id":"12","time":"2014-05-08 00:00:00",
    "station":"2",
    "valueAvg":"0.6212805",
    "valueNow":"0.5",
    "valueMax":"1.220001","timeMax":"2014-05-07 23:01:00",
    "valueMin":"0.5","timeMin":"2014-05-07 23:57:30"
  },
  ...
  ...
  ...
  {
    "logId_id":"35","time":"2014-05-08 23:00:00",
    "station":"2",
    "valueAvg":"1.312188333333333",
    "valueNow":"1.18",
    "valueMax":"2.100002","timeMax":"2014-05-08 22:01:00",
    "valueMin":"1.18","timeMin":"2014-05-08 22:47:30"
  }
]
\end{verbatim}
(Merk: Dette ville egentlig blitt veldig mange målinger, så de er kuttet ned til å vise første og siste for lesbarhet. Prikkene mellom målingene indikerer der de andre ville vært.)\\\\
Det blir altså vist som en array av JSON-elementer. Dette blir senere tolket og brukt til presentering i JavaScript.

«Backend» brukes også i første lasting av siden for å hente ut når første og siste måling ble gjort. Dette brukes for å begrense tilgjengelige datoer i kalenderene der brukeren velger tidsrom for datapresentasjon.

\subsubsection{Biblioteker brukt}
Dette er JavaScript-bibliotekene vi har tatt i bruk for å lage datapresentasjonen.
\begin{description}
  \item[jQuery\cite{nettside:jquery}] \hfill \\
  jQuery er et bibliotek laget for å simplifisere programmeringsprosessen. Mottoet deres er 'write less, do more', og gjengir ganske godt hva det går ut på. 
  I vår kode brukes primært jQuery for å forenkle AJAX-basert datalasting (beskrevet dypere i senere punkt), men også i enkelte for-løkker og andre småfunksjoner.
  \item[jQuery UI\cite{nettside:jqueryUI}] \hfill \\
  jQuery UI er et bibliotek som samhandler med jQuery for å tilby ulike visualiseringsløsninger. I vår kode brukes dette for bygge kalenderen der bruker kan velge tidsrom for datapresentasjon. 
  \item[Google Visualisation\cite{nettside:googlevis}] \hfill \\
  Google Visualisation er et bibliotek laget for visualisering av data gjennom grafer og diagrammer. I vår kode brukes dette for å generere linjediagrammet/linjegrafen for datapresentasjonen.
\end{description}

\subsubsection{Brukervalg}
I figur \ref{figure:brukervalg} vises de ulike valgene brukeren kan ta for å påvirke datapresentasjonen. 
\begin{figure}[H]
	\centering
    \includegraphics[width=1\textwidth]{brukervalg}
	\caption{Valgene presentert for brukeren.}
    \label{figure:brukervalg}
\end{figure}
Disse brukervalgene har blitt valgt på bakgrunn av to kriterier:
\begin{itemize}
\item Hovedfokus på å ikke overvelme brukeren, og heller vise de viktigste valgene uten at det skal gå for mye på bekostning av funksjonalitet. Et eksempel på dette, er at istedenfor at brukeren kan velge hvilke type verdier som skal vises (gjennomsnitt, maks og minimum), vises kun gjennomsnittsverdien grafisk, og de andre verdiene dersom man flytter musepekeren over en måling på grafen(slik vist i figur \ref{figure:grafiskfremvisning}).
\item Det andre vi har tatt hensyn til er hvilke ønsker arbeidsgiver hadde. Spesifikt innebar det muligheten til å vise måledata både grafisk og på tabellform, og å kunne spesifisere hvilke timer i døgnet det skal hentes ut fra.
\end{itemize}
For å sikre at ikke brukeren skal kunne gjøre noen feil når de velger, blir alle feltene sjekket hver gang det blir gjort en endring. Det vil si at brukeren kan for eksempel ikke huke bort alle timesvalgene uten at «Standard» blir automatisk huket på igjen. Lignende sikring er laget for stasjonsvalget. I kalenderen som åpnes når tekstfeltene markert «Fra» og «Til» trykkes, er det ikke mulig å verken velge datoer der det ikke er målinger (Altså før stasjone  ble montert, og etter nåtid). Det er heller ikke mulig å sette en senere fradato enn den valgte tildatoen. Alle disse sikringene kombinert, gjør at det er tilnærmet umulig å utføre brukerfeil.

\subsubsection{Dynamisk innholdslasting}
\meta{Hva, hvorfor(fordeler) og hvordan? Stikkord: AJAX}

\subsubsection{Grafisk fremvisning}
\meta{Hva, hvorfor og hvordan? Stikkord: Google Visualisation og begrensninger satt}
\begin{figure}[H]
	\centering
    \includegraphics[width=1\textwidth]{grafiskfremvisning}
	\caption{Måledata for temperatur presentert med linjediagram.}
    \label{figure:grafiskfremvisning}
\end{figure}

\subsubsection{Tabellvisning}
\meta{Hva, hvorfor og hvordan? Stikkord: html-tabeller}
\begin{figure}[H]
	\centering
    \includegraphics[width=1\textwidth]{tabellvisning}
	\caption{Måledata for temperatur presentert på tabellform.}
    \label{figure:tabellvisning}
\end{figure}

\subsubsection{Feilhåndering}
\meta{Hvordan håndteres tidsavbrudd, ikke-eksisterende data, osv.}

\subsubsection{Design}
\meta{Hva har det vært fokus på? Hvordan har dette blitt gjort i praksis. Stikkord: enkelt/lettforståelig, oversiktlig, CSS og brukerinfo(tekstboks)}

\subsubsection{Engelsk versjon}
\meta{Hvorfor, og hvordan? Hvilke filer måtte endres}

\subsubsection{Sikkerhet}
\meta{Hvilke sikkerhetsaspekter måtte tas hensyn til, og hvordan ble de løst? Stikkord: SQL-injection}

\subsubsection{Implementasjon på hessdalen.org}
\meta{Hvordan ble dette gjort? Stikkord: CSS-konflikter}
\begin{figure}[H]
	\centering
    \includegraphics[width=1\textwidth]{implementertsystem}
	\caption{Den norske versjon av datapresentasjon implementert på hessdalen.org}
    \label{figure:implementertsystem}
\end{figure}

\subsubsection{Arbeidsprosessen}
\meta{Hvilken rekkefølge ble ting gjort i? Stikkord: Hva vi begynte med, osv. Input fra arbeidsgiver}

\subsubsection{Problemer underveis}
\meta{Var det noen problemer? Hvis så, hvilke? Stikkord: Ikke all info i Google Visualisation API(ref) var helt oppdatert og mer tidkrevende enn antatt.}

\section{Arbeidsprosessen}
\meta{Si noe om hvordan vi har jobbet som gruppe. Arbeidsfordeling. Habbla Habbla.}